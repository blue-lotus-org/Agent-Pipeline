"use client"

import { useState } from "react"
import { Button } from "@/components/ui/button"
import { Settings, Download, Copy, Save, FileUp } from "lucide-react"
import SettingsModal from "./settings-modal"
import { useApiKey } from "@/hooks/use-api-key"
import { useToast } from "@/components/ui/use-toast"
import { useFlow } from "@/contexts/flow-context"

export default function Header() {
  const [isSettingsOpen, setIsSettingsOpen] = useState(false)
  const { apiKey, model } = useApiKey()
  const { nodes, edges, generatedCode, setGeneratedCode } = useFlow()
  const { toast } = useToast()

  const handleGenerateCode = () => {
    if (!apiKey) {
      toast({
        title: "API Key Required",
        description: "Please set your Mistral API key in settings first.",
        variant: "destructive",
      })
      return null
    }

    try {
      // Find input, mistral, and output nodes
      const inputNodes = nodes.filter((node) => node.type === "input")
      const mistralNodes = nodes.filter((node) => node.type === "mistral")
      const outputNodes = nodes.filter((node) => node.type === "output")

      if (inputNodes.length === 0 || mistralNodes.length === 0) {
        throw new Error("Pipeline must contain at least one input and Mistral node")
      }

      // Create a map of node connections
      const nodeConnections = new Map()
      edges.forEach((edge) => {
        if (!nodeConnections.has(edge.source)) {
          nodeConnections.set(edge.source, [])
        }
        nodeConnections.get(edge.source).push(edge.target)
      })

      // Generate code based on the pipeline
      const code = generatePipelineCode(
        inputNodes,
        mistralNodes,
        outputNodes,
        nodeConnections,
        model || "mistral-small-latest",
      )
      setGeneratedCode(code)
      return code
    } catch (error) {
      console.error("Code generation error:", error)
      toast({
        title: "Code Generation Error",
        description: error instanceof Error ? error.message : "An error occurred while generating code",
        variant: "destructive",
      })
      return null
    }
  }

  const generatePipelineCode = (
    inputNodes: any[],
    mistralNodes: any[],
    outputNodes: any[],
    nodeConnections: Map<string, string[]>,
    modelName: string,
  ) => {
    // Get the first input and mistral node for simplicity
    const inputNode = inputNodes[0]
    const mistralNode = mistralNodes[0]

    // Extract prompt from mistral node
    const prompt = mistralNode.data.prompt || "Process the following input:"
    const temperature = mistralNode.data.temperature || 0.7
    const maxTokens = mistralNode.data.maxTokens || 500

    return `
import { MistralClient } from '@mistralai/mistralai';

/**
 * Mistral AI Agent Pipeline
 * Generated by Mistral Pipeline Builder
 */

// Initialize the client with your API key
const client = new MistralClient(process.env.MISTRAL_API_KEY || "your-api-key-here");

/**
 * Main pipeline function
 * @param {string} input - The input text to process
 * @returns {Promise<string>} - The processed output
 */
async function runPipeline(input) {
  try {
    // Step 1: Preprocess the input
    const processedInput = preprocess(input);
    
    // Step 2: Generate response with Mistral AI
    const response = await client.chat({
      model: "${modelName}",
      messages: [
        { role: "system", content: \`${prompt}\` },
        { role: "user", content: processedInput }
      ],
      temperature: ${temperature},
      max_tokens: ${maxTokens}
    });
    
    // Step 3: Extract and postprocess the response
    const result = response.choices[0].message.content;
    return postprocess(result);
  } catch (error) {
    console.error("Pipeline execution error:", error);
    throw error;
  }
}

/**
 * Preprocess the input before sending to Mistral AI
 * @param {string} input - Raw input
 * @returns {string} - Processed input
 */
function preprocess(input) {
  // Add your preprocessing logic here
  return input.trim();
}

/**
 * Postprocess the output from Mistral AI
 * @param {string} output - Raw output from Mistral
 * @returns {string} - Processed output
 */
function postprocess(output) {
  // Add your postprocessing logic here
  return output.trim();
}

// Export the pipeline function
export default runPipeline;
`.trim()
  }

  const handleCopyCode = () => {
    const code = generatedCode || handleGenerateCode()
    if (code) {
      navigator.clipboard.writeText(code)
      toast({
        title: "Code Copied",
        description: "The generated code has been copied to your clipboard.",
      })
    }
  }

  const handleDownloadCode = () => {
    const code = generatedCode || handleGenerateCode()
    if (code) {
      const blob = new Blob([code], { type: "text/javascript" })
      const url = URL.createObjectURL(blob)
      const a = document.createElement("a")
      a.href = url
      a.download = "mistral-pipeline.js"
      document.body.appendChild(a)
      a.click()
      document.body.removeChild(a)
      URL.revokeObjectURL(url)
      toast({
        title: "Code Downloaded",
        description: "The generated code has been downloaded as mistral-pipeline.js",
      })
    }
  }

  const handleSavePipeline = () => {
    try {
      const pipelineData = {
        nodes,
        edges,
        model,
        version: "1.0.0",
      }

      const blob = new Blob([JSON.stringify(pipelineData, null, 2)], { type: "application/json" })
      const url = URL.createObjectURL(blob)
      const a = document.createElement("a")
      a.href = url
      a.download = "mistral-pipeline.json"
      document.body.appendChild(a)
      a.click()
      document.body.removeChild(a)
      URL.revokeObjectURL(url)

      toast({
        title: "Pipeline Saved",
        description: "Your pipeline has been saved as a JSON file.",
      })
    } catch (error) {
      console.error("Save pipeline error:", error)
      toast({
        title: "Save Error",
        description: "An error occurred while saving the pipeline",
        variant: "destructive",
      })
    }
  }

  const handleLoadPipeline = () => {
    const input = document.createElement("input")
    input.type = "file"
    input.accept = ".json"
    input.onchange = (event: any) => {
      const file = event.target.files[0]
      if (file) {
        const reader = new FileReader()
        reader.onload = (e: any) => {
          try {
            const pipelineData = JSON.parse(e.target.result)

            // Dispatch a custom event with the pipeline data
            // This will be caught by the pipeline builder component
            window.dispatchEvent(
              new CustomEvent("loadPipeline", {
                detail: pipelineData,
              }),
            )

            toast({
              title: "Pipeline Loaded",
              description: "Your pipeline has been loaded successfully.",
            })
          } catch (error) {
            console.error("Load pipeline error:", error)
            toast({
              title: "Load Error",
              description: "An error occurred while loading the pipeline",
              variant: "destructive",
            })
          }
        }
        reader.readAsText(file)
      }
    }
    input.click()
  }

  return (
    <header className="border-b border-border">
      <div className="container mx-auto px-4 py-3 flex items-center justify-between">
        <div className="flex items-center space-x-2">
          <h1 className="text-xl font-bold">Mistral AI Pipeline Builder</h1>
        </div>

        <div className="flex items-center space-x-2">
          <Button variant="outline" size="sm" onClick={handleSavePipeline} disabled={!apiKey || nodes.length === 0}>
            <Save className="h-4 w-4 mr-2" />
            Save
          </Button>

          <Button variant="outline" size="sm" onClick={handleLoadPipeline}>
            <FileUp className="h-4 w-4 mr-2" />
            Load
          </Button>

          <Button variant="outline" size="sm" onClick={handleCopyCode} disabled={!apiKey || nodes.length === 0}>
            <Copy className="h-4 w-4 mr-2" />
            Copy Code
          </Button>

          <Button variant="outline" size="sm" onClick={handleDownloadCode} disabled={!apiKey || nodes.length === 0}>
            <Download className="h-4 w-4 mr-2" />
            Download
          </Button>

          <Button variant="ghost" size="icon" onClick={() => setIsSettingsOpen(true)}>
            <Settings className="h-5 w-5" />
          </Button>
        </div>
      </div>

      <SettingsModal isOpen={isSettingsOpen} onClose={() => setIsSettingsOpen(false)} />
    </header>
  )
}

